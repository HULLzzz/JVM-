***
# JVM的五大区
***
- 每个区域的存储和作用
***
java虚拟机运行时数据区分为五个部分：方法区，虚拟机栈，本地方法栈，堆，程序计数器。
## 程序计数器
他可以看作当前程序执行的字节码的行号指示器，JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任意时刻，一个处理器都只执行一条线程中的指令，为了线程切换后能回到正确的执行位置，每个线程都有自己独立的程序计数器，各线程之间的计数器相互独立互不影响，是线程私有的一块内存。
## java虚拟机栈
线程私有，存放编译期可知的各种基本数据类型和对象的引用.
## 本地方法栈
虚拟机栈为java（字节码）方法服务，本地方法栈为native方法服务。
## java堆
线程共享，用于存放对象的实例，是垃圾收集器管理的主要区域，java堆中还可以分为新生代和老年代
## 方法区
用于存储已经被加载的类信息，常量，静态变量，线程共享，包含的元素是整个程序中唯一的元素，即class static变量
***
### 对象的创建
> 虚拟机遇到一条new指令的时候，首先检查这个指令参数是否能在常量池中定位到类的符号引用，检查这个符号引用代表的类是否已经被加载，解析和初始化过，（若没有则必须先进行这些步骤），然后在堆中为新生对象分配内存，将分配到的内存空间初始化为零值，对对象进行必要的设置，例如这个对象是哪个类的实例，如何找到类的元数据信息，对象的哈希码，对象的GC分代年龄信息等，然后执行<init>方法，按照程序员意愿对对象进行初始化。通过句柄访问对象：在java堆中划分出一块句柄池，分别存储到对象实例数据的指针和到对象类型数据的指针。

# 垃圾回收机制
* 常用的GC算法
* 收集器的种类和适用场景
* fullGC和MinorGC的触发条件
***
## 常用的GC算法
判断对象已死：可达性分析<br>
如果一个对象到GC roots对象之间没有任何引用链，证明该对象不可达。可以作为GC roots的对象有：虚拟机栈中的引用对象，方法区中的静态属性引用对象，方法区中的常量引用对象
1. 标记-清除算法<br>
   标记所有需要回收的对象，标记完成之后进行统一回收被标记的对象，标记清除之后会产生大量不连续的内存碎片，空间的碎片太多可能会导致程序在运行过程中需要分配比较大的对象的时候由于没有找到足够的连续内存空间而再次触发回收机制。
2. 复制算法<br>
将可用的内存容量划分为大小相等的两块，每次用完了一块将存活的对象复制到另一块中，将使用过的内存一次性清理。但是对象存活率较高的时候效率变低，并且浪费内存空间
3. 标记-整理算法<br>
让存活的对象向一端移动，直接清理掉端边界以外的内存。
4。 分代收集算法<br>
目前商业中使用的最多的就是分代算法，根据对象存活的周期将java堆内存分为新生代和老年代，在新生代每次都有大量的对象死去，可以使用复制算法，老年代使用标记整理或者标记清理算法。
## 垃圾收集器的种类和适用场景
1. serial收集器<br>
单线程收集器，他在执行垃圾回收的时候

   
