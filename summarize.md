***
# JVM的五大区
***
- 每个区域的存储和作用
***
java虚拟机运行时数据区分为五个部分：方法区，虚拟机栈，本地方法栈，堆，程序计数器。
## 程序计数器
他可以看作当前程序执行的字节码的行号指示器，JVM的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任意时刻，一个处理器都只执行一条线程中的指令，为了线程切换后能回到正确的执行位置，每个线程都有自己独立的程序计数器，各线程之间的计数器相互独立互不影响，是线程私有的一块内存。
## java虚拟机栈
线程私有，存放编译期可知的各种基本数据类型和对象的引用.
## 本地方法栈
虚拟机栈为java（字节码）方法服务，本地方法栈为native方法服务。
## java堆
线程共享，用于存放对象的实例，是垃圾收集器管理的主要区域，java堆中还可以分为新生代和老年代
## 方法区
用于存储已经被加载的类信息，常量，静态变量，线程共享，包含的元素是整个程序中唯一的元素，即class static变量
***
### 对象的创建
> 虚拟机遇到一条new指令的时候，首先检查这个指令参数是否能在常量池中定位到类的符号引用，检查这个符号引用代表的类是否已经被加载，解析和初始化过，（若没有则必须先进行这些步骤），然后在堆中为新生对象分配内存，将分配到的内存空间初始化为零值，对对象进行必要的设置，例如这个对象是哪个类的实例，如何找到类的元数据信息，对象的哈希码，对象的GC分代年龄信息等，然后执行<init>方法，按照程序员意愿对对象进行初始化。通过句柄访问对象：在java堆中划分出一块句柄池，分别存储到对象实例数据的指针和到对象类型数据的指针。

# 垃圾回收机制
* 常用的GC算法
* 收集器的种类和适用场景
* fullGC和MinorGC的触发条件
***
## 常用的GC算法
判断对象已死：可达性分析<br>
如果一个对象到GC roots对象之间没有任何引用链，证明该对象不可达。可以作为GC roots的对象有：虚拟机栈中的引用对象，方法区中的静态属性引用对象，方法区中的常量引用对象
1. 标记-清除算法<br>
   标记所有需要回收的对象，标记完成之后进行统一回收被标记的对象，标记清除之后会产生大量不连续的内存碎片，空间的碎片太多可能会导致程序在运行过程中需要分配比较大的对象的时候由于没有找到足够的连续内存空间而再次触发回收机制。
2. 复制算法<br>
将可用的内存容量划分为大小相等的两块，每次用完了一块将存活的对象复制到另一块中，将使用过的内存一次性清理。但是对象存活率较高的时候效率变低，并且浪费内存空间
3. 标记-整理算法<br>
让存活的对象向一端移动，直接清理掉端边界以外的内存。
4。 分代收集算法<br>
目前商业中使用的最多的就是分代算法，根据对象存活的周期将java堆内存分为新生代和老年代，在新生代每次都有大量的对象死去，可以使用复制算法，老年代使用标记整理或者标记清理算法。持久代中存放类信息。
## 垃圾收集器的种类和适用场景
1. serial/serial old收集器<br>
单线程收集器，他在执行垃圾回收的时候必须暂停其他所有的工作线程。serial old是serial的老年代版本，新生代采用复制算法，老年代采用标记整理算法
2. parNew收集器<br>
是serial的多线程版本，使用多线程进行垃圾收集
3. parallel scavenge/parallel old收集器<br>
新生代收集器，使用复制算法的多线程收集器，他的目标是达到一个可控的吞吐量，提供两个参数控制最大垃圾收集停顿时间和吞吐量大小。吞吐量=运行代码的时间/（运行代码的时间+垃圾收集时间），高的吞吐量可以高效利用CPU时间，主要适用与后台运行不需要太多交互的任务。注重吞吐量和CPU资源敏感的场合优先考虑这两个组合。老年代收集器采用标记整理算法。
4. CMS(concurrent mark sweep)<br>
以获取最短停顿时间为目标的收集器，基于标记清除算法，垃圾回收过程和用户线程是同时进行的。缺点：无法清除浮动垃圾（用户程序运行过程中也会产生垃圾，这些垃圾出现在标记之后，就无法在本次回收中进行回收），标记清除算法会产生大量的内存碎片。
5. G1收集器<br>
并行与并发，分代收集，空间整合，可预测的停顿，他将java堆划分为多个大小相等的独立区域（region）保留新生代和老年代的概念，但是不再是物理隔离的了。G1跟踪各个region里面垃圾堆积的价值大小，在后台维护一个优先列表。
```
串行处理器：
适用情况：数据量比较小（100M左右）；单处理器下并且对响应时间无要求的应用。
缺点：只能用于小型应用

并行处理器：
适用情况：“对吞吐量有高要求”，多CPU、对应用响应时间无要求的中、大型应用。举例：后台处理、科学计算。
缺点：垃圾收集过程中应用响应时间可能加长（老年代使用的默认是串行垃圾处理）

并发处理器：
适用情况：“对响应时间有高要求”，多CPU、对应用响应时间有较高要求的中、大型应用。举例：Web服务器/应用服务器、电信交换、集成开发环境。
```
```
java -Xmx3550m -Xms3550m -Xmn2g –Xss128k

-Xmx3550m：设置JVM最大可用内存为3550M。

-Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。

-Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。

-Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。
```
## fullGC和minorGC的触发条件
对象现在新生代EDEN区中分配。eden区没有足够的空间进行分配的时候虚拟机将发起一次minorGC，虚拟机给每个对象定义了一个年龄计数器，对象在eden区出生并经过一次minorGC之后任然存活，并能被survivor容纳的话，将被移动到survivor空间（有参数可设置survivor空间和eden空间的内存大小比），并将对象的年龄设置为1，对象在这里每经过一次minorGC年龄就增加一岁，到达一定年龄就进入到老年代，只有一个survivor只有一个进行替换（为了内存利用率），survivor无法容纳的对象将直接进入老年代，这时候会和老年代的剩余空间比较，决定是否进行fullGC。JDK6之后规定，只要老年代生于连续空间的大小大于新生代对象的总大小或者历次晋升的平均大小就会触发minorGC，否则进行fullGC。<br>
以下会触发fullGC的情况:<br>
``` 
 年老代（Tenured）被写满
 持久代被写满
 System.gc()被显示调用 
 上一次GC之后Heap的各域分配策略动态变化
```

# JVM内存模型
* 类加载机制
* 双亲委派模型
***
## 类加载机制
>类文件结构<br>
常量池：字面量和符号引用，java代码是在虚拟机加载class文件的时候进行动态链接，编译后的class文件中不会保存各个方法字段的最终内存布局信息，而是在运行期间进行转换为真正的内存入口地址。当虚拟机运行的时候需要从常量池中获得相应的符号引用，在类创建的或运行时解析翻译到具体的内存地址。

虚拟机的类加载机制：虚拟机将描述类的数据从class文件加载到内存，并对数据进行校验，转换和解析，初始化，最终形成可以直接使用的java类型。<br>
* 类的生命周期：加载，验证，准备，解析，初始化，使用，卸载<br>
触发初始化：遇到new，getstatic，putstatic，invokestatic字节码指令的时候时首先进行初始化。主要场景（new一个新对象的时候，读取，设置类的静态字段的时候，调用类的静态方法的时候）。使用java.lang.reflect包的方法对类进行反射调用的时候。通过子类引用父类的静态方法的时候只触发父类的初始化。
* 加载 <br>
将clas文件中类的二进制数据读取到内存中，将字节流中的静态存储结构转换为方法区中的运行时的数据结构，在堆中生成一个代表这个类的java.lang.class对象，作为方法区中这个类的数据的访问入口。
* 准备<br>
为类的静态变量分配内存设置类变量设置初始值（零值），仅为类变量（被static修饰的变量）分配内存，实例变量将在对象实例化的时候与对象一起分配在java堆中。final定义的变量的初始化为赋予他的值，其他的则为规定的零值。
* 解析<br>
虚拟机将常量池中的符号引用替换为直接引用的过程，java类编译为class文件后常量池中的符号引用并没有对应实际的内存地址，而在运行期的时候，经过加载分配好内存，在解析时将符号引用转换为实际的内存地址。
* 初始化<br>
在初始化的阶段才真正执行类中定义的java程序的字节码。时执行类构造器<clinit>()方法的过程。<clinit>()方法是自动收集类中所有类变量的赋值东顾总和静态语块中的语句合并产生的。虚拟机会保证一个类的<clinit>()方法在多线程中被正确的加锁，同步，如果多线程同时初始化一个类，那么只有一个线程去执行这个方法。（这也是单例模式中使用static静态代码块进行对象初始化的原因）
   
## 双亲委派模型
一个类加载器收到的类的加载请求，他不会自己尝试加载这个类，而是将请求委派给父类加载器完成，每一个层次的类加载器都是如此，所有的加载请求都传送到顶层的启动类加载器中，只有父类加载器反馈自己无法完成加载的时候子类加载器才会尝试自己去加载。
>java的平台无关性：java程序编译为class文件（字节码），JMV将字节码翻译为相应平台的机器码，对应的平台操作系统执行相应的机器码指令。

# JVM优化
看到一篇总结的很好的博客 ： [JVM调优](https://www.cnblogs.com/andy-zhou/p/5327288.html)，参考其中有关内存泄漏检查的总结。
## 四种引用
* 强引用<br>
就是我们一般声明对象是时虚拟机生成的引用，强引用环境下，垃圾回收时需要严格判断当前对象是否被强引用，如果被强引用，则不会被垃圾回收
* 软引用<br>
软引用一般被做为缓存来使用。与强引用的区别是，软引用在垃圾回收时，虚拟机会根据当前系统的剩余内存来决定是否对软引用进行回收。如果剩余内存比较紧张，则虚拟机会回收软引用所引用的空间；如果剩余内存相对富裕，则不会进行回收。换句话说，虚拟机在发生OutOfMemory时，肯定是没有软引用存在的。
* 弱引用<br>
弱引用与软引用类似，都是作为缓存来使用。但与软引用不同，弱引用在进行垃圾回收时，是一定会被回收掉的，因此其生命周期只存在于一个垃圾回收周期内。
* 虚引用



# 基础知识补充
* java是传值还是传引用<br>
Java在方法调用传递参数时，因为没有指针，所以它都是进行传值调用（这点可以参考C的传值调用）。因此，很多书里面都说Java是进行传值调用，这点没有问题，而且也简化的C中复杂性。但是传引用的错觉是如何造成的呢？在运行栈中，基本类型和引用的处理是一样的，都是传值，所以，如果是传引用的方法调用，也同时可以理解为“传引用值”的传值调用，即引用的处理跟基本类型是完全一样的。但是当进入被调用方法时，被传递的这个引用的值，被程序解释（或者查找）到堆中的对象，这个时候才对应到真正的对象。如果此时进行修改，修改的是引用对应的对象，而不是引用本身，即：修改的是堆中的数据。所以这个修改是可以保持的了。









































   
